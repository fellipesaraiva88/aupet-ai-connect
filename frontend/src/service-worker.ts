/// <reference lib="webworker" />

import { clientsClaim } from 'workbox-core';
import { ExpirationPlugin } from 'workbox-expiration';
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { StaleWhileRevalidate, CacheFirst, NetworkFirst } from 'workbox-strategies';

declare const self: ServiceWorkerGlobalScope;

clientsClaim();

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Set up App Shell-style routing for SPA
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$');
registerRoute(
  ({ request, url }: { request: Request; url: URL }) => {
    if (request.mode !== 'navigate') {
      return false;
    }

    if (url.pathname.startsWith('/_')) {
      return false;
    }

    if (url.pathname.match(fileExtensionRegexp)) {
      return false;
    }

    return true;
  },
  createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
);

// Cache API responses with different strategies
registerRoute(
  ({ url }) => url.origin === self.location.origin && url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'auzap-api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
      }),
    ],
  })
);

// Cache Supabase API calls
registerRoute(
  ({ url }) => url.origin.includes('supabase') && url.pathname.includes('/rest/'),
  new StaleWhileRevalidate({
    cacheName: 'supabase-api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 10 * 60, // 10 minutes
      }),
    ],
  })
);

// Cache images with long-term strategy
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'auzap-images',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 500,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 Days
      }),
    ],
  })
);

// Cache Google Fonts
registerRoute(
  ({ url }) => url.origin === 'https://fonts.googleapis.com',
  new StaleWhileRevalidate({
    cacheName: 'google-fonts-stylesheets',
  })
);

registerRoute(
  ({ url }) => url.origin === 'https://fonts.gstatic.com',
  new CacheFirst({
    cacheName: 'google-fonts-webfonts',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 30,
        maxAgeSeconds: 60 * 60 * 24 * 365, // 1 year
      }),
    ],
  })
);

// Cache static assets
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'manifest',
  new StaleWhileRevalidate({
    cacheName: 'auzap-static-resources',
  })
);

// Background sync for offline messages
const QUEUE_NAME = 'whatsapp-messages';

interface QueuedMessage {
  id: string;
  type: 'send-message' | 'update-status' | 'sync-data';
  data: any;
  timestamp: number;
  retryCount?: number;
}

class MessageQueue {
  private queue: QueuedMessage[] = [];
  private processing = false;

  async add(message: QueuedMessage) {
    this.queue.push(message);
    await this.saveQueue();

    if (!this.processing) {
      this.processQueue();
    }
  }

  private async processQueue() {
    if (this.processing || this.queue.length === 0) return;

    this.processing = true;

    while (this.queue.length > 0) {
      const message = this.queue.shift()!;

      try {
        await this.processMessage(message);
      } catch (error) {
        console.error('Failed to process queued message:', error);

        // Retry logic
        message.retryCount = (message.retryCount || 0) + 1;
        if (message.retryCount < 3) {
          this.queue.unshift(message); // Put back at front
          await new Promise(resolve => setTimeout(resolve, 1000 * message.retryCount!));
        }
      }
    }

    this.processing = false;
    await this.saveQueue();
  }

  private async processMessage(message: QueuedMessage) {
    switch (message.type) {
      case 'send-message':
        await this.sendMessage(message.data);
        break;
      case 'update-status':
        await this.updateStatus(message.data);
        break;
      case 'sync-data':
        await this.syncData(message.data);
        break;
    }
  }

  private async sendMessage(data: any) {
    const response = await fetch('/api/whatsapp/send', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

  private async updateStatus(data: any) {
    const response = await fetch(`/api/messages/${data.id}/status`, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ status: data.status }),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

  private async syncData(data: any) {
    const response = await fetch('/api/sync', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(data),
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }
  }

  private async saveQueue() {
    try {
      const cache = await caches.open('auzap-queue');
      await cache.put(
        new Request('/offline-queue'),
        new Response(JSON.stringify(this.queue))
      );
    } catch (error) {
      console.error('Failed to save queue:', error);
    }
  }

  async loadQueue() {
    try {
      const cache = await caches.open('auzap-queue');
      const response = await cache.match('/offline-queue');

      if (response) {
        const queueData = await response.json();
        this.queue = queueData || [];
      }
    } catch (error) {
      console.error('Failed to load queue:', error);
    }
  }
}

const messageQueue = new MessageQueue();

// Initialize queue on startup
self.addEventListener('install', (event) => {
  event.waitUntil(messageQueue.loadQueue());
  self.skipWaiting();
});

self.addEventListener('activate', (event) => {
  event.waitUntil(clients.claim());
});

// Handle background sync
self.addEventListener('sync', (event) => {
  if (event.tag === QUEUE_NAME) {
    event.waitUntil(messageQueue.loadQueue());
  }
});

// Handle messages from the main thread
self.addEventListener('message', (event) => {
  const { type, data } = event.data;

  switch (type) {
    case 'QUEUE_MESSAGE':
      messageQueue.add({
        id: data.id || Date.now().toString(),
        type: data.type,
        data: data.payload,
        timestamp: Date.now(),
      });
      break;

    case 'SKIP_WAITING':
      self.skipWaiting();
      break;

    case 'GET_VERSION':
      event.ports[0].postMessage({ version: '1.0.0' });
      break;
  }
});

// Push notification handling
self.addEventListener('push', (event) => {
  if (!event.data) return;

  try {
    const data = event.data.json();

    const options: NotificationOptions = {
      body: data.body,
      icon: '/images/icons/icon-192x192.png',
      badge: '/images/icons/badge-72x72.png',
      data: data.data,
      actions: [
        {
          action: 'reply',
          title: 'Responder',
        },
        {
          action: 'view',
          title: 'Visualizar',
        },
      ],
      tag: data.tag || 'default',
      requireInteraction: data.requireInteraction || false,
      silent: data.silent || false,
      vibrate: data.vibrate || [200, 100, 200],
    };

    event.waitUntil(
      self.registration.showNotification(data.title, options)
    );
  } catch (error) {
    console.error('Error handling push notification:', error);
  }
});

// Notification click handling
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const { action, data } = event;
  const urlToOpen = data?.url || '/';

  event.waitUntil(
    clients.matchAll({ type: 'window', includeUncontrolled: true }).then((clientList) => {
      // Check if there's already a window/tab open with the URL
      for (const client of clientList) {
        if (client.url === urlToOpen && 'focus' in client) {
          return client.focus();
        }
      }

      // If not, open a new window/tab
      if (clients.openWindow) {
        return clients.openWindow(urlToOpen);
      }
    })
  );

  // Handle specific actions
  if (action === 'reply' && data?.conversationId) {
    // Open reply interface
    clients.openWindow(`/conversations/${data.conversationId}?reply=true`);
  } else if (action === 'view' && data?.url) {
    // Open specific view
    clients.openWindow(data.url);
  }
});

// Handle online/offline status
self.addEventListener('online', () => {
  // Process queued messages when back online
  messageQueue.loadQueue();
});

// Periodic background sync for data updates
self.addEventListener('periodicsync', (event) => {
  if (event.tag === 'sync-data') {
    event.waitUntil(
      messageQueue.add({
        id: 'periodic-sync-' + Date.now(),
        type: 'sync-data',
        data: { type: 'periodic' },
        timestamp: Date.now(),
      })
    );
  }
});

// Share target handling
self.addEventListener('fetch', (event) => {
  const url = new URL(event.request.url);

  // Handle share target
  if (url.pathname === '/share' && event.request.method === 'POST') {
    event.respondWith(handleShareTarget(event.request));
  }
});

async function handleShareTarget(request: Request): Promise<Response> {
  try {
    const formData = await request.formData();
    const title = formData.get('title') as string;
    const text = formData.get('text') as string;
    const url = formData.get('url') as string;
    const files = formData.getAll('files') as File[];

    // Process shared data
    const shareData = {
      title,
      text,
      url,
      files: files.map(file => ({
        name: file.name,
        type: file.type,
        size: file.size,
      })),
    };

    // Store shared data for the app to retrieve
    const cache = await caches.open('auzap-shared-data');
    await cache.put(
      new Request('/shared-data'),
      new Response(JSON.stringify(shareData))
    );

    // Redirect to the share handling page
    return Response.redirect('/share-received', 302);
  } catch (error) {
    console.error('Error handling share target:', error);
    return new Response('Error processing shared content', { status: 500 });
  }
}