/// <reference types="vite/client" />
/// <reference lib="webworker" />

import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute, NavigationRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst, StaleWhileRevalidate } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';
import { BackgroundSyncPlugin } from 'workbox-background-sync';
import { Queue } from 'workbox-background-sync';

declare let self: ServiceWorkerGlobalScope;

const SW_VERSION = '1.0.0';
const CACHE_PREFIX = 'auzap-v1';

// Precache all of the assets generated by your build process
precacheAndRoute(self.__WB_MANIFEST);

// Clean up outdated caches
cleanupOutdatedCaches();

// Cache Strategy: API Calls
registerRoute(
  ({ request }) => request.destination === '' && request.url.includes('/api/'),
  new NetworkFirst({
    cacheName: `${CACHE_PREFIX}-api-cache`,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 5 * 60, // 5 minutes
        purgeOnQuotaError: true
      })
    ]
  })
);

// Cache Strategy: Images
registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-images`,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 200,
        maxAgeSeconds: 30 * 24 * 60 * 60, // 30 days
        purgeOnQuotaError: true
      })
    ]
  })
);

// Cache Strategy: Fonts
registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: `${CACHE_PREFIX}-fonts`,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 365 * 24 * 60 * 60, // 1 year
        purgeOnQuotaError: true
      })
    ]
  })
);

// Cache Strategy: Static Assets (CSS, JS)
registerRoute(
  ({ request }) =>
    request.destination === 'script' ||
    request.destination === 'style' ||
    request.destination === 'worker',
  new StaleWhileRevalidate({
    cacheName: `${CACHE_PREFIX}-static-assets`,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 100,
        maxAgeSeconds: 7 * 24 * 60 * 60, // 7 days
        purgeOnQuotaError: true
      })
    ]
  })
);

// Cache Strategy: HTML Pages (SPA Navigation)
const navigationRoute = new NavigationRoute(
  new NetworkFirst({
    cacheName: `${CACHE_PREFIX}-pages`,
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 24 * 60 * 60, // 1 day
        purgeOnQuotaError: true
      })
    ]
  })
);

registerRoute(navigationRoute);

// Background Sync for offline actions
const bgSyncPlugin = new BackgroundSyncPlugin('offline-actions', {
  maxRetentionTime: 24 * 60 // Retry for max of 24 hours (in minutes)
});

// Queue for offline messages
const messageQueue = new Queue('whatsapp-messages', {
  onSync: async ({ queue }) => {
    let entry;
    while ((entry = await queue.shiftRequest())) {
      try {
        await fetch(entry.request);
        console.log('Offline message sent successfully');

        // Notify the main thread
        self.clients.matchAll().then(clients => {
          clients.forEach(client => {
            client.postMessage({
              type: 'SYNC_SUCCESS',
              data: { action: 'message_sent' }
            });
          });
        });
      } catch (error) {
        console.error('Failed to send offline message:', error);

        // Re-add to queue if failed
        await queue.unshiftRequest(entry);

        // Notify the main thread
        self.clients.matchAll().then(clients => {
          clients.forEach(client => {
            client.postMessage({
              type: 'SYNC_ERROR',
              data: { action: 'message_failed', error: error.message }
            });
          });
        });
      }
    }
  }
});

// Handle offline form submissions
registerRoute(
  ({ request }) =>
    request.method === 'POST' &&
    (request.url.includes('/api/messages') ||
     request.url.includes('/api/appointments') ||
     request.url.includes('/api/customers') ||
     request.url.includes('/api/pets')),
  new NetworkFirst({
    cacheName: `${CACHE_PREFIX}-api-posts`,
    plugins: [bgSyncPlugin]
  })
);

// Push Notifications
self.addEventListener('push', (event) => {
  if (!event.data) return;

  const data = event.data.json();
  const options: NotificationOptions = {
    body: data.body,
    icon: '/icons/icon-192x192.png',
    badge: '/icons/badge-72x72.png',
    vibrate: [200, 100, 200],
    requireInteraction: true,
    actions: [
      {
        action: 'view',
        title: 'Ver Conversa',
        icon: '/icons/action-view.png'
      },
      {
        action: 'reply',
        title: 'Responder',
        icon: '/icons/action-reply.png'
      }
    ],
    data: data.data,
    tag: data.tag || 'default',
    renotify: true,
    timestamp: Date.now()
  };

  event.waitUntil(
    self.registration.showNotification(data.title || 'Nova mensagem', options)
  );
});

// Notification Click Handler
self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const action = event.action;
  const data = event.notification.data;

  event.waitUntil(
    (async () => {
      const clients = await self.clients.matchAll({
        type: 'window',
        includeUncontrolled: true
      });

      // Check if app is already open
      for (const client of clients) {
        if (client.url.includes(self.location.origin)) {
          await client.focus();

          if (action === 'view' && data?.conversationId) {
            client.postMessage({
              type: 'NAVIGATE_TO_CONVERSATION',
              conversationId: data.conversationId
            });
          } else if (action === 'reply' && data?.conversationId) {
            client.postMessage({
              type: 'OPEN_REPLY_MODAL',
              conversationId: data.conversationId
            });
          }

          return;
        }
      }

      // Open new window if app not open
      let url = '/';
      if (action === 'view' && data?.conversationId) {
        url = `/conversations/${data.conversationId}`;
      } else if (action === 'reply' && data?.conversationId) {
        url = `/conversations/${data.conversationId}?reply=true`;
      }

      await self.clients.openWindow(url);
    })()
  );
});

// Handle sync events
self.addEventListener('sync', (event) => {
  if (event.tag === 'background-sync') {
    event.waitUntil(messageQueue.replayRequests());
  }
});

// Message handler for communication with main thread
self.addEventListener('message', (event) => {
  const { type, data } = event.data;

  switch (type) {
    case 'SKIP_WAITING':
      self.skipWaiting();
      break;

    case 'CACHE_URLS':
      event.waitUntil(
        caches.open(`${CACHE_PREFIX}-runtime`).then(cache => {
          return cache.addAll(data.urls);
        })
      );
      break;

    case 'CLEAR_CACHE':
      event.waitUntil(
        caches.keys().then(cacheNames => {
          return Promise.all(
            cacheNames.map(cacheName => {
              if (cacheName.startsWith(CACHE_PREFIX)) {
                return caches.delete(cacheName);
              }
            })
          );
        })
      );
      break;

    case 'GET_VERSION':
      event.ports[0].postMessage({ version: SW_VERSION });
      break;
  }
});

// Install event
self.addEventListener('install', (event) => {
  console.log(`Service Worker ${SW_VERSION} installing`);

  // Skip waiting to activate immediately
  self.skipWaiting();
});

// Activate event
self.addEventListener('activate', (event) => {
  console.log(`Service Worker ${SW_VERSION} activated`);

  // Take control of all pages immediately
  event.waitUntil(self.clients.claim());

  // Clean up old caches
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName.includes('auzap') && !cacheName.includes('v1')) {
            console.log('Deleting old cache:', cacheName);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});

// Fetch event with offline fallback
self.addEventListener('fetch', (event) => {
  // Skip non-GET requests for background sync
  if (event.request.method !== 'GET') {
    return;
  }

  // Handle navigation requests with offline fallback
  if (event.request.mode === 'navigate') {
    event.respondWith(
      fetch(event.request).catch(() => {
        return caches.match('/offline.html') ||
               caches.match('/') ||
               new Response('Offline - Please check your connection', {
                 status: 503,
                 statusText: 'Service Unavailable'
               });
      })
    );
  }
});

// Error handling
self.addEventListener('error', (event) => {
  console.error('Service Worker error:', event.error);
});

self.addEventListener('unhandledrejection', (event) => {
  console.error('Service Worker unhandled rejection:', event.reason);
});

export {};